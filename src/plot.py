from src.config import *

def LaTeX(truefalse: bool) -> None:
    """Toggle LaTeX rendering in matplotlib.

    Args:
        truefalse (bool): If True, enable LaTeX rendering with sans-serif font.
                          If False, disable LaTeX rendering.

    Returns:
        None
    """
    if truefalse:
        plt.rcParams.update({
            "text.usetex": True,
            "font.family": "sans-serif",
            "font.sans-serif": "avant"
        })
    else:
        plt.rcParams.update({
            "text.usetex": False,
            "font.sans-serif": "DejaVu Sans",
        })
    return None

def plot_random_shape(theta: np.ndarray, radius: np.ndarray, fourier_series_order: int) -> None:
    """Plot a random shape in polar coordinates using Fourier series.

    Args:
        theta (np.ndarray): Array of angles in radians.
        radius (np.ndarray): Array of radii corresponding to theta.
        fourier_series_order (int): The order of the Fourier series used to generate the shape.

    Returns:
        None
    """
    figsize = 4
    _, ax = plt.subplots(
        subplot_kw={'projection': 'polar'},
        figsize=(figsize,figsize),
        dpi = 100
        )
    ax.set_title(f"Random shape generated by \n a order-{fourier_series_order} Fourier series")
    ax.plot(theta, radius)
    ax.grid(True)
    ax.fill_between(theta,0,radius,alpha=0.2)
    plt.show()
    return None


def plot_discrete_grid(grid: np.ndarray, pixel_dimension: int) -> None:
    """Plot the discrete grid representation of a shape.

    Args:
        grid (np.ndarray): 2D array representing the discrete grid.
        pixel_dimension (int): The dimension of the grid in pixels (assumed square).

    Returns:
        None
    """
    figsize = 4
    _, ax = plt.subplots(
        1,1,
        figsize=(figsize,figsize),
        dpi=100
        )
    ax.set_title(f"Discrete representation of the random shape\n Image size: ({pixel_dimension},{pixel_dimension}) pixels")
    ax.set_xticks([])
    ax.set_yticks([])
    plt.imshow(grid.T, cmap=cmr.ocean, origin='lower', interpolation='nearest')
    plt.show()
    return None

def plot_discrete_grid_boundary(grid: np.ndarray, boundary: np.ndarray) -> None:
    """Plot the discrete grid with the boundary highlighted.

    Args:
        grid (np.ndarray): 2D array representing the discrete grid.
        boundary (np.ndarray): 2D array representing the boundary overlay.

    Returns:
        None
    """
    figsize = 4
    _, ax = plt.subplots(
        1,1,
        figsize=(figsize,figsize),
        dpi=100
        )
    ax.set_title(f"Discrete boundary highlighted")
    ax.set_xticks([])
    ax.set_yticks([])
    plt.imshow(grid.T, cmap=cmr.ocean, origin='lower', interpolation='nearest')
    plt.imshow(boundary.T, cmap=cmr.neutral, origin='lower', interpolation='nearest', alpha = 0.7)
    plt.show()
    return None

def plot_conversion_ratios(ratio_order0: np.ndarray, ratio_order1: np.ndarray, ratio_order2: np.ndarray, bins: int) -> None:
    """Plot the conversion ratios for different boundary orders.

    Args:
        ratio_order0 (np.ndarray): Array of conversion ratios for 0th-order boundary.
        ratio_order1 (np.ndarray): Array of conversion ratios for 1st-order boundary.
        ratio_order2 (np.ndarray): Array of conversion ratios for 2nd-order boundary.
        bins (int, optional): Number of bins for the histograms. Defaults to 30.

    Returns:
        None
    """

    # Plot the conversion factors
    fig, axes = plt.subplots(1, 3, figsize=(18, 5), dpi=100, sharey=True)
    fig.suptitle('Conversion factors found for boundaries of different order', fontsize=15, fontweight='bold')

    # Plot for order 0
    mean0 = np.mean(ratio_order0)
    std0_abs = np.std(ratio_order0)
    std0_norm = std0_abs / mean0
    axes[0].hist(ratio_order0, alpha=0.7, bins=bins, color='skyblue', edgecolor='black', linewidth=0.5)
    axes[0].set_title('0th-order boundary', fontsize=12)
    axes[0].set_xlabel('Ratio')
    axes[0].set_ylabel('Frequency')
    axes[0].grid(True, alpha=0.3)
    axes[0].xaxis.set_major_locator(ticker.MaxNLocator(5))
    axes[0].xaxis.set_major_formatter(ticker.FormatStrFormatter('%.2f'))
    axes[0].text(0.5, -0.3, f'Normalized std dev: {std0_norm:.3f}\n'+rf'Found conversion factor: ${mean0:.3f} \pm {std0_abs:.3f}$', transform=axes[0].transAxes, ha='center', fontsize=10)

    # Plot for order 1
    mean1 = np.mean(ratio_order1)
    std1_abs = np.std(ratio_order1)
    std1_norm = std1_abs / mean1
    axes[1].hist(ratio_order1, alpha=0.7, bins=bins, color='lightgreen', edgecolor='black', linewidth=0.5)
    axes[1].set_title('1st-order boundary', fontsize=12)
    axes[1].set_xlabel('Ratio')
    axes[1].set_ylabel('Frequency')
    axes[1].grid(True, alpha=0.3)
    axes[1].xaxis.set_major_locator(ticker.MaxNLocator(5))
    axes[1].xaxis.set_major_formatter(ticker.FormatStrFormatter('%.2f'))
    axes[1].text(0.5, -0.3, f'Normalized std dev: {std1_norm:.3f}\n'+rf'Found conversion factor: ${mean1:.3f} \pm {std1_abs:.3f}$', transform=axes[1].transAxes, ha='center', fontsize=10)

    # Plot for order 2
    mean2 = np.mean(ratio_order2)
    std2_abs = np.std(ratio_order2)
    std2_norm = std2_abs / mean2
    axes[2].hist(ratio_order2, alpha=0.7, bins=bins, color='salmon', edgecolor='black', linewidth=0.5)
    axes[2].set_title('2nd-order boundary', fontsize=12)
    axes[2].set_xlabel('Ratio')
    axes[2].set_ylabel('Frequency')
    axes[2].grid(True, alpha=0.3)
    axes[2].xaxis.set_major_locator(ticker.MaxNLocator(5))
    axes[2].xaxis.set_major_formatter(ticker.FormatStrFormatter('%.3f'))
    axes[2].text(0.5, -0.3, f'Normalized std dev: {std2_norm:.3f}\n'+rf'Found conversion factor: ${mean2:.3f} \pm {std2_abs:.3f}$', transform=axes[2].transAxes, ha='center', fontsize=10)

    plt.tight_layout()
    plt.subplots_adjust(bottom=0.3)
    plt.show()
    return None